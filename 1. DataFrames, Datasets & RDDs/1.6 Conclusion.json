{"paragraphs":[{"user":"anonymous","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"editorMode":"ace/mode/markdown","editorHide":true,"tableHide":false},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1556116637303_-72915453","id":"20190424-163717_1121679874","dateCreated":"2019-04-24T16:37:17+0200","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:31663","text":"%md <img src='https://global-uploads.webflow.com/5ad0acc69f356a98471287a3/5ae073d500595f83d49e713a_logo_Comsysto-Reply_color.svg' style='width:400px'>","dateUpdated":"2019-04-24T16:37:24+0200","dateFinished":"2019-04-24T16:37:24+0200","dateStarted":"2019-04-24T16:37:24+0200","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<img src='https://global-uploads.webflow.com/5ad0acc69f356a98471287a3/5ae073d500595f83d49e713a_logo_Comsysto-Reply_color.svg' style='width:400px'>\n</div>"}]}},{"text":"%md\n# 1.6 Conclusion","user":"anonymous","dateUpdated":"2019-04-24T16:37:30+0200","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"editorMode":"ace/mode/markdown","editorHide":true,"tableHide":false},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1556116644983_406145948","id":"20190424-163724_1544939763","dateCreated":"2019-04-24T16:37:24+0200","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:31741","dateFinished":"2019-04-24T16:37:30+0200","dateStarted":"2019-04-24T16:37:30+0200","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>1.6 Conclusion</h1>\n</div>"}]}},{"text":"%md\n### RDDs\nRDDs remain the core component for the native distributed collections.\nBut due to lack of built-in optimization, DFs and DSs should be prefered. \n\n\n### DataFrames\n**DataFrames** and **Spark SQL** are very flexible and bring built-in optimization also for dynamic languages like Python and R. Beside this, it allows to combine both *declarative* and *functional* way of working with structured data.\nIt's regarded to be most stable and flexible API.\n\n<img src='https://databricks.com/wp-content/uploads/2015/02/Screen-Shot-2015-02-16-at-9.46.39-AM-1024x457.png' style='width:400px'>\n\n\n### Datasets\n**Datasets** unify the best from both worlds: **type safety** from **RDDs** and **built-in optimization** available for **DataFrames**. DSs allow even further optimizations (memory compaction + faster serialization using encoders).\n\nHere some benchmarks of DataSets:\n\n<img src='https://databricks.com/wp-content/uploads/2016/01/Distributed-Wordcount-Chart-1024x371.png' style='width:400px'>\n<img src='https://databricks.com/wp-content/uploads/2016/01/Memory-Usage-when-Caching-Chart-1024x359.png?noresize' style='width:400px'>\n\n","user":"anonymous","dateUpdated":"2019-04-24T16:37:36+0200","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"editorMode":"ace/mode/markdown","editorHide":true,"tableHide":false},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1556116650598_-932383343","id":"20190424-163730_696337015","dateCreated":"2019-04-24T16:37:30+0200","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:31835","dateFinished":"2019-04-24T16:37:36+0200","dateStarted":"2019-04-24T16:37:36+0200","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>RDDs</h3>\n<p>RDDs remain the core component for the native distributed collections.<br/>But due to lack of built-in optimization, DFs and DSs should be prefered. </p>\n<h3>DataFrames</h3>\n<p><strong>DataFrames</strong> and <strong>Spark SQL</strong> are very flexible and bring built-in optimization also for dynamic languages like Python and R. Beside this, it allows to combine both <em>declarative</em> and <em>functional</em> way of working with structured data.<br/>It&rsquo;s regarded to be most stable and flexible API.</p>\n<img src='https://databricks.com/wp-content/uploads/2015/02/Screen-Shot-2015-02-16-at-9.46.39-AM-1024x457.png' style='width:400px'>\n<h3>Datasets</h3>\n<p><strong>Datasets</strong> unify the best from both worlds: <strong>type safety</strong> from <strong>RDDs</strong> and <strong>built-in optimization</strong> available for <strong>DataFrames</strong>. DSs allow even further optimizations (memory compaction + faster serialization using encoders).</p>\n<p>Here some benchmarks of DataSets:</p>\n<img src='https://databricks.com/wp-content/uploads/2016/01/Distributed-Wordcount-Chart-1024x371.png' style='width:400px'>\n<img src='https://databricks.com/wp-content/uploads/2016/01/Memory-Usage-when-Caching-Chart-1024x359.png?noresize' style='width:400px'>\n</div>"}]}}],"name":"/1. DataFrames, Datasets & RDDs/1.6 Conclusion","id":"2EAKXQ192","noteParams":{},"noteForms":{},"angularObjects":{"md:shared_process":[],"python:shared_process":[],"spark:shared_process":[]},"config":{"isZeppelinNotebookCronEnable":false,"looknfeel":"default","personalizedMode":"false"},"info":{}}